import { TwitterSpaceDubbingAgent } from './agents/TwitterSpaceDubbingAgent';
import { config } from './utils/config';
import logger from './utils/logger';
import * as fs from 'fs';
import * as path from 'path';
// Assuming LeaderboardEntry might be defined elsewhere or we use a generic type for now
import { LeaderboardEntry } from './services/scraperService'; // Import if defined in scraperService, otherwise define locally or in types/

const LEADERBOARD_DATA_PATH = path.join(process.cwd(), 'leaderboard_data.json');

/**
 * Loads leaderboard data from the JSON file.
 */
function loadLeaderboardData(): LeaderboardEntry[] | null {
    logger.info(`Attempting to load leaderboard data from ${LEADERBOARD_DATA_PATH}...`);
    if (!fs.existsSync(LEADERBOARD_DATA_PATH)) {
        logger.error(`‚ùå Error: Leaderboard data file not found at ${LEADERBOARD_DATA_PATH}.`);
        logger.error(`Please run the Python scraper utility first: python scraper_utility/scrape_leaderboard.py`);
        return null;
    }
    try {
        const fileContent = fs.readFileSync(LEADERBOARD_DATA_PATH, 'utf-8');
        const data = JSON.parse(fileContent);
        // Basic validation: check if it's an array
        if (!Array.isArray(data)) {
             logger.error(`‚ùå Error: Invalid format in ${LEADERBOARD_DATA_PATH}. Expected a JSON array.`);
             return null;
        }
        // TODO: Add more robust validation using Pydantic-like checks or Zod if needed
        logger.info(`‚úÖ Successfully loaded ${data.length} entries from ${LEADERBOARD_DATA_PATH}.`);
        return data as LeaderboardEntry[]; // Cast to the expected type
    } catch (error) {
        logger.error(`‚ùå Error reading or parsing ${LEADERBOARD_DATA_PATH}:`, error);
        return null;
    }
}

/**
 * Main application entry point.
 */
async function main() {
    logger.info('===================================================');
    logger.info('üöÄ Starting Twitter Space Dubbing Agent (Node.js)...');
    logger.info('===================================================');

    // Load data generated by the Python scraper
    const leaderboardEntries = loadLeaderboardData();

    if (!leaderboardEntries || leaderboardEntries.length === 0) {
        logger.error('Agent cannot proceed without leaderboard data. Exiting.');
        process.exitCode = 1;
        return;
    }

    const agent = new TwitterSpaceDubbingAgent();

    try {
        logger.info(`‚ñ∂Ô∏è Processing ${leaderboardEntries.length} entries from leaderboard data...`);

        for (const entry of leaderboardEntries) {
            // TODO: Adapt agent.processSingleProfile to accept LeaderboardEntry 
            // or create a new method agent.processLeaderboardEntry(entry)
            logger.info(`--- Processing Entry: ${entry.spaceTitle || entry.directSpaceUrl || 'Unknown'} ---`);
            
            // Placeholder for calling the agent logic with the entry data
            // For now, just log - replace with actual agent call later
            // await agent.processLeaderboardEntry(entry); 
            logger.debug(`   Host: ${entry.hostProfileUrl}`);
            logger.debug(`   Space Link: ${entry.directSpaceUrl}`);

            // Implement delay between processing entries
            logger.info(`[‚è≥] Waiting ${config.DELAY_BETWEEN_PROFILES_MS / 1000}s before next entry...`);
            await new Promise(resolve => setTimeout(resolve, config.DELAY_BETWEEN_PROFILES_MS));
            logger.info(`---------------------------------------------------`);
        }

        logger.info('===================================================');
        logger.info('‚úÖ Agent processing finished.');
        logger.info('===================================================');

    } catch (error) {
        logger.error('‚ùå Agent encountered a fatal error during processing loop:', error);
        process.exitCode = 1; // Indicate failure
    } finally {
        logger.info('Agent shutting down.');
    }
}

// Execute the main function
main(); 