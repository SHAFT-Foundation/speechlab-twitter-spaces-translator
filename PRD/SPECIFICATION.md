# AI Agent: Twitter Space Scraper, Dubber, and Poster

## 1. Overview

This document specifies the requirements for a Node.js TypeScript AI agent designed to:
1.  Scrape top Twitter profiles from SpacesDashboard.
2.  Identify recent recorded Twitter Spaces for those profiles.
3.  Extract the audio stream URL (`.m3u8`) for these Spaces.
4.  Download and host the audio publicly (AWS S3).
5.  Submit the audio to the SpeechLab API for dubbing into Latin American Spanish (`es_la`).
6.  Monitor project status and wait for completion.
7.  Retrieve a sharing link for the completed SpeechLab project.
8.  Post this sharing link as a reply to the original Twitter Space tweet.

## Workflow Overview

This project consists of two main parts:

1.  **Python Scraper Utility (`scraper_utility/`):** Uses the `nova-act` library (AI-driven browser automation) or Playwright to scrape the SpacesDashboard leaderboard. It extracts structured data (Space Title, Host Profile URL, Direct Space URL) for each entry and saves it to `leaderboard_data_playwright.json` in the project root.
2.  **Node.js Dubbing Agent (`src/`):** Reads the `leaderboard_data_playwright.json` file generated by the Python utility. For each entry in the file, it performs the dubbing workflow (Phases 2-7): finds the specific tweet (if needed, or uses the direct space URL), downloads/uploads audio, submits to SpeechLab, monitors processing status, gets the sharing link, and posts the link back to Twitter.

## 2. Functional Requirements

### Phase 1: Scrape Leaderboard Data (Python Utility - `scraper_utility/scrape_leaderboard_playwright.py`)

*   **Goal:** Extract structured data for leaderboard entries and save to a file.
*   **Tool:** Python script using Playwright or `nova-act` library.
*   **Input:** SpacesDashboard Leaderboard URL (`https://spacesdashboard.com/leaderboard?lang=en&mode=7d`).
*   **Method:**
    *   Launch browser targeting the leaderboard URL.
    *   Identify distinct leaderboard entries.
    *   Extract `space_title`, `host_handle`, `host_name`, `listener_count`, and `direct_play_url` from PLAY button link.
    *   Handle potential scrolling to load more entries.
    *   Deduplicate entries based on `direct_play_url`.
*   **Output:** Creates/overwrites `leaderboard_data_playwright.json` in the project root, containing an array of objects:
    ```json
    [
      {
        "space_title": "Example Space Title",
        "host_handle": "@exampleHost",
        "host_name": "Example Host Name",
        "listener_count": 12345,
        "direct_play_url": "https://x.com/i/spaces/12345example"
      },
      // ... more entries
    ]
    ```
*   **Execution:** Run manually via `python scraper_utility/scrape_leaderboard_playwright.py --headless=False` after setting up the Python environment.

### Phase 2: Find Recorded Space & Extract Audio URL (Node.js Agent)

*   **Goal:** Extract the `.m3u8` audio stream URL for a given recorded Twitter Space.
*   **Input:** A `LeaderboardEntry` object (read from `leaderboard_data_playwright.json`), specifically the `directSpaceUrl`.
*   **Service:** `twitterInteractionService.ts`
*   **Method:**
    *   Use Playwright to navigate directly to the `directSpaceUrl`.
    *   Identify the element indicating a recorded space (e.g., "Play recording" button).
    *   Simulate clicking the "Play recording" button.
    *   Intercept network requests to capture the `*.pscp.tv/.../playlist_*.m3u8` URL.
    *   Also attempt to extract the original tweet URL from the page for later reply posting.
*   **Key Function:** `getM3u8ForSpacePage(directSpaceUrl)`
*   **Output:** `{ m3u8Url: string, originalTweetUrl: string|null }` or null if failed.
*   **Logging:** `[üê¶ Twitter]` prefixed log messages.

### Phase 3: Download, Convert, and Host Audio

*   **Goal:** Download audio from the `.m3u8` URL and upload it to a public AWS S3 bucket.
*   **Input:** The `.m3u8` URL and space name (for filename).
*   **Service:** `audioService.ts`
*   **Method:**
    *   Use `ffmpeg` to download and save the stream as a single file (e.g., `.aac` or `.mp3`).
    *   Use the AWS SDK for JavaScript v3 to upload the audio to S3.
    *   Configure the upload with `public-read` ACL.
    *   Use a temporary directory to store audio files, with cleanup.
*   **Key Function:** `downloadAndUploadAudio(m3u8Url, spaceName)`
*   **Output:** The public URL of the hosted audio file on S3.
*   **Logging:** `[üéß Audio]` prefixed log messages for download progress, conversion status, and upload completion.

### Phase 4: Dub Audio using SpeechLab API

*   **Goal:** Submit the hosted audio file to the SpeechLab API for dubbing.
*   **Input:** Public S3 URL, Space Name
*   **Service:** `speechlabApiService.ts`
*   **Method:**
    *   Get authentication token via `getAuthToken()` using credentials from `.env`.
    *   Construct project name and thirdPartyID from the space name.
    *   Submit a POST request to create a dubbing project:
        *   Endpoint: `POST /v1/projects/createProjectAndDub`
        *   Parameters: name, sourceLanguage, targetLanguage, dubAccent, unitType, mediaFileURI, voiceMatchingMode, thirdPartyID.
*   **Key Function:** `createDubbingProject(publicAudioUrl, spaceName)`
*   **Output:** SpeechLab `projectId`
*   **Logging:** `[ü§ñ SpeechLab]` prefixed logs for API requests, responses, and errors.

### Phase 5: Monitor Project Processing Status

*   **Goal:** Wait for the SpeechLab project to complete processing.
*   **Input:** The thirdPartyID used when creating the project.
*   **Service:** `speechlabApiService.ts`
*   **Method:**
    *   Poll the API at regular intervals (default 30 seconds) to check project status.
    *   Look up project by thirdPartyID using the `getProjectByThirdPartyID` function.
    *   Extract status (PROCESSING, COMPLETE, FAILED) and progress percentage.
    *   Continue polling until status is COMPLETE, FAILED, or maximum wait time is reached.
    *   For debugging, log project details and write detailed diagnostic files.
*   **Key Functions:** 
    *   `waitForProjectCompletion(thirdPartyID, maxWaitTimeMs, checkIntervalMs)`
    *   `getProjectByThirdPartyID(thirdPartyID)`
*   **Output:** Boolean indicating whether project completed successfully.
*   **Logging:** Detailed progress logs with current status, estimated time remaining, and poll count.

### Phase 6: Get SpeechLab Sharing Link

*   **Goal:** Obtain the public sharing link for the completed dubbing project.
*   **Input:** SpeechLab `projectId`
*   **Service:** `speechlabApiService.ts`
*   **Method:**
    *   Get authentication token.
    *   POST request to generate a sharing link:
        *   Endpoint: `/v1/collaborations/generateSharingLink`
        *   Request Body: `{"projectId": "PROJECT_ID_FROM_PHASE_4"}`
    *   Extract the `link` field from the response.
*   **Key Function:** `generateSharingLink(projectId)`
*   **Output:** Sharing link URL string
*   **Logging:** `[ü§ñ SpeechLab]` prefixed logs for link generation progress.

### Phase 7: Post Comment to Twitter

*   **Goal:** Post the SpeechLab sharing link as a reply to the original Twitter Space tweet.
*   **Input:** Original Tweet URL, SpeechLab Sharing Link
*   **Service:** `twitterInteractionService.ts`
*   **Method:**
    *   Use several approaches to find a suitable tweet to reply to:
        *   Use the original tweet URL if found in Phase 2
        *   Look for tweets on the host's profile that reference this Space
        *   Find any Space-related tweet on the host's profile
        *   Find any tweet embedding the Space
    *   Generate comment text including the timestamp, sharing link, and attribution.
    *   Use Playwright to navigate to the tweet URL and post a reply.
*   **Key Functions:** 
    *   `postReplyToTweet(tweetUrl, commentText)`
    *   `findSpaceTweetFromProfile(hostUsername, spaceId)`
    *   `findTweetEmbeddingSpace(spaceUrl)`
*   **Output:** Boolean indicating success/failure of posting
*   **Logging:** `[üê¶ Twitter]` prefixed logs for tweet finding and reply posting.

### Phase 8: Send Direct Message to Space Host

*   **Goal:** Send the SpeechLab sharing link as a direct message to the Twitter Space host.
*   **Input:** Host username, SpeechLab Sharing Link
*   **Service:** `twitterInteractionService.ts`
*   **Method:**
    *   Send a direct message to the host (identified by username) containing the same text as the tweet reply.
    *   Use Playwright to navigate to Twitter's messages page, search for the user, and send the message.
    *   Implemented as a fallback if tweet reply posting fails or as an additional notification mechanism.
*   **Key Function:** `sendDirectMessage(username, messageText)`
*   **Output:** Boolean indicating success/failure of DM sending
*   **Logging:** `[üê¶ Twitter]` prefixed logs for DM sending process.

## 3. Agent Orchestration (Node.js Agent - `src/agents/TwitterSpaceDubbingAgent.ts` and `src/main.ts`)

1.  **Initialization:** Agent starts in `main.ts`.
2.  **Load Leaderboard Data:**
    *   Read and parse `leaderboard_data_playwright.json` from the project root.
    *   Map the data to the required `LeaderboardEntry` format.
    *   Filter entries to include only those with a valid `direct_play_url`.
3.  **Iterate Entries:** Loop through the loaded entries.
    *   For each entry, call `agent.processLeaderboardEntry(entry)`, which:
        *   Validates required input and prepares parameters.
        *   Executes Phases 2-7 in sequence using the corresponding service functions.
        *   Handles errors and continues to the next entry if one phase fails.
        *   Returns a `ProcessingResult` object indicating whether processing was attempted and successful.
    *   Implement configurable delay between processing entries.
4.  **Completion:** Log agent run completion.

## 4. Project Structure

```
.
‚îú‚îÄ‚îÄ PRD/
‚îÇ   ‚îî‚îÄ‚îÄ SPECIFICATION.md
‚îú‚îÄ‚îÄ scraper_utility/          <-- Python Scraper
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îî‚îÄ‚îÄ scrape_leaderboard_playwright.py
‚îú‚îÄ‚îÄ src/                      <-- Node.js Dubbing Agent
‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TwitterSpaceDubbingAgent.ts
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ twitterInteractionService.ts 
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ audioService.ts           
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ speechlabApiService.ts      
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scraperService.ts
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logger.ts
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ main.ts
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ leaderboard_data_playwright.json <-- Generated by Python utility
‚îú‚îÄ‚îÄ .env                       <-- Environment variables
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ tsconfig.json
```

## 5. Open Questions Addressed

*   Source Language: `en`
*   Audio Hosting: AWS S3, bucket `speechlab-test-files-public`, using env credentials.
*   Sharing Link API: `POST /v1/collaborations/generateSharingLink`, link is in `link` field.
*   Twitter Interaction: Browser automation via Playwright.
*   Logging: Detailed, structured, with icons and prefixes.
*   Voice Matching: `source`.

## 6. Error Handling and Diagnostics

The system incorporates comprehensive error handling and diagnostic features:

1. **Detailed Logging:** Each phase has unique log prefixes and icons for clear identification.
2. **Debug Files:** Writes API responses, errors, and diagnostic information to files:
   - `temp_api_response.json`: Full API response from SpeechLab
   - `project_not_found.json`: Details when no projects are found for a thirdPartyID
   - `api_error.json`: Error details for troubleshooting
   - `third_party_id.txt`: The thirdPartyID used for the current project

3. **Graceful Degradation:** If any phase fails, the agent logs the error and moves to the next entry rather than crashing.
4. **Retries and Polling:** For time-sensitive operations, the agent implements polling with configurable parameters.
5. **Multiple Approaches:** For tweet finding, implements multiple fallback approaches if the primary method fails. 