import { TwitterSpaceDubbingAgent } from './agents/TwitterSpaceDubbingAgent';
import { config } from './utils/config';
import logger from './utils/logger';
import * as fs from 'fs';
import * as path from 'path';
// Assuming LeaderboardEntry might be defined elsewhere or we use a generic type for now
import { LeaderboardEntry } from './services/scraperService'; // Import if defined in scraperService, otherwise define locally or in types/

// Update to use the new Playwright scraper output file
const LEADERBOARD_DATA_PATH = path.join(process.cwd(), 'leaderboard_data_playwright.json');

/**
 * Loads leaderboard data from the JSON file and maps to the required format.
 */
function loadLeaderboardData(): LeaderboardEntry[] | null {
    logger.info(`Attempting to load leaderboard data from ${LEADERBOARD_DATA_PATH}...`);
    if (!fs.existsSync(LEADERBOARD_DATA_PATH)) {
        logger.error(`‚ùå Error: Leaderboard data file not found at ${LEADERBOARD_DATA_PATH}.`);
        logger.error(`Please run the Python scraper utility first: python scraper_utility/scrape_leaderboard_playwright.py --headless=False`);
        return null;
    }
    try {
        const fileContent = fs.readFileSync(LEADERBOARD_DATA_PATH, 'utf-8');
        const rawData = JSON.parse(fileContent);
        
        // Basic validation: check if it's an array
        if (!Array.isArray(rawData)) {
             logger.error(`‚ùå Error: Invalid format in ${LEADERBOARD_DATA_PATH}. Expected a JSON array.`);
             return null;
        }
        
        // Map the Playwright format data to our required LeaderboardEntry format
        const mappedData: LeaderboardEntry[] = rawData
            .filter(entry => !!entry.direct_play_url) // Only entries with direct_play_url
            .map(entry => ({
                spaceTitle: entry.space_title || null,
                hostProfileUrl: entry.host_handle ? `https://x.com/${entry.host_handle.replace('@', '')}` : null,
                directSpaceUrl: entry.direct_play_url || null,
                // Additional data we can use
                hostHandle: entry.host_handle || null,
                hostName: entry.host_name || null,
                listenerCount: entry.listener_count || 0,
                thirdPartyId: entry.space_title || `Space by ${entry.host_handle || 'Unknown'}`
            }));
            
        logger.info(`‚úÖ Successfully loaded and mapped ${mappedData.length} entries from ${LEADERBOARD_DATA_PATH}.`);
        logger.debug(`Original data had ${rawData.length} entries, filtered to ${mappedData.length} with direct Space URLs.`);
        
        return mappedData;
    } catch (error) {
        logger.error(`‚ùå Error reading or parsing ${LEADERBOARD_DATA_PATH}:`, error);
        return null;
    }
}

/**
 * Main application entry point.
 */
async function main() {
    logger.info('===================================================');
    logger.info('üöÄ Starting Twitter Space Dubbing Agent (Node.js)...');
    logger.info('===================================================');

    // Load data generated by the Python scraper
    const leaderboardEntries = loadLeaderboardData();

    if (!leaderboardEntries || leaderboardEntries.length === 0) {
        logger.error('Agent cannot proceed without leaderboard data. Exiting.');
        process.exitCode = 1;
        return;
    }

    const agent = new TwitterSpaceDubbingAgent();

    try {
        logger.info(`‚ñ∂Ô∏è Processing ${leaderboardEntries.length} entries from leaderboard data...`);

        for (const entry of leaderboardEntries) {
            logger.info(`--- Processing Entry: ${entry.spaceTitle || entry.directSpaceUrl || 'Unknown'} ---`);
            logger.debug(`   Host: ${entry.hostProfileUrl} (${entry.hostHandle || 'Unknown'})`);
            logger.debug(`   Space Link: ${entry.directSpaceUrl}`);
            
            // Process entry using the agent and get a result indicating if processing was attempted
            const processingResult = await agent.processLeaderboardEntry(entry);
            
            // Only wait if the entry was actually processed (had a valid play button)
            // This prevents unnecessary waiting when the entry wasn't valid
            if (processingResult.processingAttempted) {
                logger.info(`[‚è≥] Waiting ${config.DELAY_BETWEEN_PROFILES_MS / 1000}s before next entry...`);
                await new Promise(resolve => setTimeout(resolve, config.DELAY_BETWEEN_PROFILES_MS));
            } else {
                logger.info(`Skipping delay - entry was quickly determined to be invalid.`);
            }
            logger.info(`---------------------------------------------------`);
        }

        logger.info('===================================================');
        logger.info('‚úÖ Agent processing finished.');
        logger.info('===================================================');

    } catch (error) {
        logger.error('‚ùå Unhandled error in main process:', error);
        process.exitCode = 1;
    }
}

// Start the application
main().catch(error => {
    logger.error('‚ùå Fatal error:', error);
    process.exit(1);
}); 